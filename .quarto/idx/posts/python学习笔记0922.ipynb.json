{"title":"python再入门","markdown":{"headingText":"python再入门","containsRefs":false,"markdown":"\n<h1>Table of Contents<span class=\"tocSkip\"></span></h1>\n<div class=\"toc\"><ul class=\"toc-item\"><li><span><a href=\"#再入门基础\" data-toc-modified-id=\"再入门基础-1\"><span class=\"toc-item-num\">1&nbsp;&nbsp;</span>再入门基础</a></span><ul class=\"toc-item\"><li><span><a href=\"#包的引用\" data-toc-modified-id=\"包的引用-1.1\"><span class=\"toc-item-num\">1.1&nbsp;&nbsp;</span>包的引用</a></span></li><li><span><a href=\"#整数\" data-toc-modified-id=\"整数-1.2\"><span class=\"toc-item-num\">1.2&nbsp;&nbsp;</span>整数</a></span></li><li><span><a href=\"#字符串\" data-toc-modified-id=\"字符串-1.3\"><span class=\"toc-item-num\">1.3&nbsp;&nbsp;</span>字符串</a></span></li><li><span><a href=\"#行话\" data-toc-modified-id=\"行话-1.4\"><span class=\"toc-item-num\">1.4&nbsp;&nbsp;</span>行话</a></span></li><li><span><a href=\"#自省\" data-toc-modified-id=\"自省-1.5\"><span class=\"toc-item-num\">1.5&nbsp;&nbsp;</span>自省</a></span></li><li><span><a href=\"#%run命令\" data-toc-modified-id=\"%run命令-1.6\"><span class=\"toc-item-num\">1.6&nbsp;&nbsp;</span>%run命令</a></span></li><li><span><a href=\"#jupyter-notebook-中的神奇命令\" data-toc-modified-id=\"jupyter-notebook-中的神奇命令-1.7\"><span class=\"toc-item-num\">1.7&nbsp;&nbsp;</span>jupyter notebook 中的神奇命令</a></span><ul class=\"toc-item\"><li><span><a href=\"#编辑模式（按esc进入）\" data-toc-modified-id=\"编辑模式（按esc进入）-1.7.1\"><span class=\"toc-item-num\">1.7.1&nbsp;&nbsp;</span>编辑模式（按esc进入）</a></span></li><li><span><a href=\"#命令模式（按enter进入）\" data-toc-modified-id=\"命令模式（按enter进入）-1.7.2\"><span class=\"toc-item-num\">1.7.2&nbsp;&nbsp;</span>命令模式（按enter进入）</a></span></li></ul></li></ul></li><li><span><a href=\"#python数据结构\" data-toc-modified-id=\"python数据结构-2\"><span class=\"toc-item-num\">2&nbsp;&nbsp;</span>python数据结构</a></span><ul class=\"toc-item\"><li><span><a href=\"#元组\" data-toc-modified-id=\"元组-2.1\"><span class=\"toc-item-num\">2.1&nbsp;&nbsp;</span>元组</a></span></li><li><span><a href=\"#列表\" data-toc-modified-id=\"列表-2.2\"><span class=\"toc-item-num\">2.2&nbsp;&nbsp;</span>列表</a></span></li><li><span><a href=\"#集合\" data-toc-modified-id=\"集合-2.3\"><span class=\"toc-item-num\">2.3&nbsp;&nbsp;</span>集合</a></span></li><li><span><a href=\"#NumPy\" data-toc-modified-id=\"NumPy-2.4\"><span class=\"toc-item-num\">2.4&nbsp;&nbsp;</span>NumPy</a></span></li><li><span><a href=\"#基本控制流\" data-toc-modified-id=\"基本控制流-2.5\"><span class=\"toc-item-num\">2.5&nbsp;&nbsp;</span>基本控制流</a></span></li><li><span><a href=\"#复杂数据结构\" data-toc-modified-id=\"复杂数据结构-2.6\"><span class=\"toc-item-num\">2.6&nbsp;&nbsp;</span>复杂数据结构</a></span></li><li><span><a href=\"#数组属性\" data-toc-modified-id=\"数组属性-2.7\"><span class=\"toc-item-num\">2.7&nbsp;&nbsp;</span>数组属性</a></span><ul class=\"toc-item\"><li><span><a href=\"#NumPy数组索引\" data-toc-modified-id=\"NumPy数组索引-2.7.1\"><span class=\"toc-item-num\">2.7.1&nbsp;&nbsp;</span>NumPy数组索引</a></span></li><li><span><a href=\"#combination\" data-toc-modified-id=\"combination-2.7.2\"><span class=\"toc-item-num\">2.7.2&nbsp;&nbsp;</span>combination</a></span></li><li><span><a href=\"#随机森林\" data-toc-modified-id=\"随机森林-2.7.3\"><span class=\"toc-item-num\">2.7.3&nbsp;&nbsp;</span>随机森林</a></span></li><li><span><a href=\"#处理数据\" data-toc-modified-id=\"处理数据-2.7.4\"><span class=\"toc-item-num\">2.7.4&nbsp;&nbsp;</span>处理数据</a></span></li><li><span><a href=\"#从pandas中提取数据（后面补充）\" data-toc-modified-id=\"从pandas中提取数据（后面补充）-2.7.5\"><span class=\"toc-item-num\">2.7.5&nbsp;&nbsp;</span>从pandas中提取数据（后面补充）</a></span></li></ul></li><li><span><a href=\"#Numpy数组的运算\" data-toc-modified-id=\"Numpy数组的运算-2.8\"><span class=\"toc-item-num\">2.8&nbsp;&nbsp;</span>Numpy数组的运算</a></span><ul class=\"toc-item\"><li><span><a href=\"#算术运算\" data-toc-modified-id=\"算术运算-2.8.1\"><span class=\"toc-item-num\">2.8.1&nbsp;&nbsp;</span>算术运算</a></span></li><li><span><a href=\"#逐元素运算与张量点乘运算\" data-toc-modified-id=\"逐元素运算与张量点乘运算-2.8.2\"><span class=\"toc-item-num\">2.8.2&nbsp;&nbsp;</span>逐元素运算与张量点乘运算</a></span></li><li><span><a href=\"#广播机制(broadcasting)\" data-toc-modified-id=\"广播机制(broadcasting)-2.8.3\"><span class=\"toc-item-num\">2.8.3&nbsp;&nbsp;</span>广播机制(broadcasting)</a></span></li><li><span><a href=\"#矩阵运算\" data-toc-modified-id=\"矩阵运算-2.8.4\"><span class=\"toc-item-num\">2.8.4&nbsp;&nbsp;</span>矩阵运算</a></span></li></ul></li><li><span><a href=\"#爱因斯坦求和约定\" data-toc-modified-id=\"爱因斯坦求和约定-2.9\"><span class=\"toc-item-num\">2.9&nbsp;&nbsp;</span>爱因斯坦求和约定</a></span></li><li><span><a href=\"#NumPy的轴方向\" data-toc-modified-id=\"NumPy的轴方向-2.10\"><span class=\"toc-item-num\">2.10&nbsp;&nbsp;</span>NumPy的轴方向</a></span></li><li><span><a href=\"#NumPy的高级索引\" data-toc-modified-id=\"NumPy的高级索引-2.11\"><span class=\"toc-item-num\">2.11&nbsp;&nbsp;</span>NumPy的高级索引</a></span></li><li><span><a href=\"#数组的堆叠操作\" data-toc-modified-id=\"数组的堆叠操作-2.12\"><span class=\"toc-item-num\">2.12&nbsp;&nbsp;</span>数组的堆叠操作</a></span></li><li><span><a href=\"#数组NumPy的随机数\" data-toc-modified-id=\"数组NumPy的随机数-2.13\"><span class=\"toc-item-num\">2.13&nbsp;&nbsp;</span>数组NumPy的随机数</a></span></li><li><span><a href=\"#EDA-introduction\" data-toc-modified-id=\"EDA-introduction-2.14\"><span class=\"toc-item-num\">2.14&nbsp;&nbsp;</span>EDA introduction</a></span><ul class=\"toc-item\"><li><span><a href=\"#异构列表\" data-toc-modified-id=\"异构列表-2.14.1\"><span class=\"toc-item-num\">2.14.1&nbsp;&nbsp;</span>异构列表</a></span></li></ul></li><li><span><a href=\"#维数化简\" data-toc-modified-id=\"维数化简-2.15\"><span class=\"toc-item-num\">2.15&nbsp;&nbsp;</span>维数化简</a></span><ul class=\"toc-item\"><li><span><a href=\"#协方差矩阵\" data-toc-modified-id=\"协方差矩阵-2.15.1\"><span class=\"toc-item-num\">2.15.1&nbsp;&nbsp;</span>协方差矩阵</a></span></li><li><span><a href=\"#主成分分析\" data-toc-modified-id=\"主成分分析-2.15.2\"><span class=\"toc-item-num\">2.15.2&nbsp;&nbsp;</span>主成分分析</a></span></li><li><span><a href=\"#2.2.3处理大数据集\" data-toc-modified-id=\"2.2.3处理大数据集-2.15.3\"><span class=\"toc-item-num\">2.15.3&nbsp;&nbsp;</span>2.2.3处理大数据集</a></span></li><li><span><a href=\"#3.3.3-一种用于大数据的PCA变型——Randomized-PCA\" data-toc-modified-id=\"3.3.3-一种用于大数据的PCA变型——Randomized-PCA-2.15.4\"><span class=\"toc-item-num\">2.15.4&nbsp;&nbsp;</span>3.3.3 一种用于大数据的PCA变型——Randomized PCA</a></span></li><li><span><a href=\"#3.3.4-潜在因素分析\" data-toc-modified-id=\"3.3.4-潜在因素分析-2.15.5\"><span class=\"toc-item-num\">2.15.5&nbsp;&nbsp;</span>3.3.4 潜在因素分析</a></span></li><li><span><a href=\"#3.3.5-线性判别分析\" data-toc-modified-id=\"3.3.5-线性判别分析-2.15.6\"><span class=\"toc-item-num\">2.15.6&nbsp;&nbsp;</span>3.3.5 线性判别分析</a></span></li></ul></li><li><span><a href=\"#3.4-异常检测和处理\" data-toc-modified-id=\"3.4-异常检测和处理-2.16\"><span class=\"toc-item-num\">2.16&nbsp;&nbsp;</span>3.4 异常检测和处理</a></span><ul class=\"toc-item\"><li><span><a href=\"#3.4.1-单变量异常检测\" data-toc-modified-id=\"3.4.1-单变量异常检测-2.16.1\"><span class=\"toc-item-num\">2.16.1&nbsp;&nbsp;</span>3.4.1 单变量异常检测</a></span></li><li><span><a href=\"#3.4.2-EllipticEnvelope\" data-toc-modified-id=\"3.4.2-EllipticEnvelope-2.16.2\"><span class=\"toc-item-num\">2.16.2&nbsp;&nbsp;</span>3.4.2 EllipticEnvelope</a></span></li><li><span><a href=\"#3.4.3-oneclassSVM\" data-toc-modified-id=\"3.4.3-oneclassSVM-2.16.3\"><span class=\"toc-item-num\">2.16.3&nbsp;&nbsp;</span>3.4.3 oneclassSVM</a></span></li></ul></li><li><span><a href=\"#3.5-评分函数\" data-toc-modified-id=\"3.5-评分函数-2.17\"><span class=\"toc-item-num\">2.17&nbsp;&nbsp;</span>3.5 评分函数</a></span><ul class=\"toc-item\"><li><span><a href=\"#3.5.1多标号分类\" data-toc-modified-id=\"3.5.1多标号分类-2.17.1\"><span class=\"toc-item-num\">2.17.1&nbsp;&nbsp;</span>3.5.1多标号分类</a></span></li><li><span><a href=\"#二值分类\" data-toc-modified-id=\"二值分类-2.17.2\"><span class=\"toc-item-num\">2.17.2&nbsp;&nbsp;</span>二值分类</a></span></li><li><span><a href=\"#回归\" data-toc-modified-id=\"回归-2.17.3\"><span class=\"toc-item-num\">2.17.3&nbsp;&nbsp;</span>回归</a></span></li></ul></li><li><span><a href=\"#交叉和验证\" data-toc-modified-id=\"交叉和验证-2.18\"><span class=\"toc-item-num\">2.18&nbsp;&nbsp;</span>交叉和验证</a></span></li><li><span><a href=\"#交叉验证\" data-toc-modified-id=\"交叉验证-2.19\"><span class=\"toc-item-num\">2.19&nbsp;&nbsp;</span>交叉验证</a></span><ul class=\"toc-item\"><li><span><a href=\"#3.7.1-使用交叉验证迭代器\" data-toc-modified-id=\"3.7.1-使用交叉验证迭代器-2.19.1\"><span class=\"toc-item-num\">2.19.1&nbsp;&nbsp;</span>3.7.1 使用交叉验证迭代器</a></span><ul class=\"toc-item\"><li><span><a href=\"#KFold\" data-toc-modified-id=\"KFold-2.19.1.1\"><span class=\"toc-item-num\">2.19.1.1&nbsp;&nbsp;</span>KFold</a></span></li></ul></li><li><span><a href=\"#3.7.2-采样和自举方法\" data-toc-modified-id=\"3.7.2-采样和自举方法-2.19.2\"><span class=\"toc-item-num\">2.19.2&nbsp;&nbsp;</span>3.7.2 采样和自举方法</a></span></li></ul></li><li><span><a href=\"#超参数优化\" data-toc-modified-id=\"超参数优化-2.20\"><span class=\"toc-item-num\">2.20&nbsp;&nbsp;</span>超参数优化</a></span></li></ul></li><li><span><a href=\"#Pandas\" data-toc-modified-id=\"Pandas-3\"><span class=\"toc-item-num\">3&nbsp;&nbsp;</span>Pandas</a></span><ul class=\"toc-item\"><li><span><a href=\"#Series数据\" data-toc-modified-id=\"Series数据-3.1\"><span class=\"toc-item-num\">3.1&nbsp;&nbsp;</span>Series数据</a></span><ul class=\"toc-item\"><li><span><a href=\"#Series创建\" data-toc-modified-id=\"Series创建-3.1.1\"><span class=\"toc-item-num\">3.1.1&nbsp;&nbsp;</span>Series创建</a></span></li><li><span><a href=\"#数据访问\" data-toc-modified-id=\"数据访问-3.1.2\"><span class=\"toc-item-num\">3.1.2&nbsp;&nbsp;</span>数据访问</a></span></li><li><span><a href=\"#Series中的向量化操作与布尔索引\" data-toc-modified-id=\"Series中的向量化操作与布尔索引-3.1.3\"><span class=\"toc-item-num\">3.1.3&nbsp;&nbsp;</span>Series中的向量化操作与布尔索引</a></span></li><li><span><a href=\"#切片操作\" data-toc-modified-id=\"切片操作-3.1.4\"><span class=\"toc-item-num\">3.1.4&nbsp;&nbsp;</span>切片操作</a></span></li><li><span><a href=\"#删除和添加\" data-toc-modified-id=\"删除和添加-3.1.5\"><span class=\"toc-item-num\">3.1.5&nbsp;&nbsp;</span>删除和添加</a></span></li></ul></li><li><span><a href=\"#DataFrame\" data-toc-modified-id=\"DataFrame-3.2\"><span class=\"toc-item-num\">3.2&nbsp;&nbsp;</span>DataFrame</a></span><ul class=\"toc-item\"><li><span><a href=\"#访问DataFrame中的列和行\" data-toc-modified-id=\"访问DataFrame中的列和行-3.2.1\"><span class=\"toc-item-num\">3.2.1&nbsp;&nbsp;</span>访问DataFrame中的列和行</a></span></li><li><span><a href=\"#DataFrame中的删除操作\" data-toc-modified-id=\"DataFrame中的删除操作-3.2.2\"><span class=\"toc-item-num\">3.2.2&nbsp;&nbsp;</span>DataFrame中的删除操作</a></span></li><li><span><a href=\"#Dataframe的轴方向\" data-toc-modified-id=\"Dataframe的轴方向-3.2.3\"><span class=\"toc-item-num\">3.2.3&nbsp;&nbsp;</span>Dataframe的轴方向</a></span></li></ul></li><li><span><a href=\"#基于Pandas的文件读取与分析\" data-toc-modified-id=\"基于Pandas的文件读取与分析-3.3\"><span class=\"toc-item-num\">3.3&nbsp;&nbsp;</span>基于Pandas的文件读取与分析</a></span></li></ul></li><li><span><a href=\"#Matplotlib-与Seaborn可视化分析\" data-toc-modified-id=\"Matplotlib-与Seaborn可视化分析-4\"><span class=\"toc-item-num\">4&nbsp;&nbsp;</span>Matplotlib 与Seaborn可视化分析</a></span><ul class=\"toc-item\"><li><span><a href=\"#Matplotlib与图形绘制\" data-toc-modified-id=\"Matplotlib与图形绘制-4.1\"><span class=\"toc-item-num\">4.1&nbsp;&nbsp;</span>Matplotlib与图形绘制</a></span></li><li><span><a href=\"#pyplot的高级功能\" data-toc-modified-id=\"pyplot的高级功能-4.2\"><span class=\"toc-item-num\">4.2&nbsp;&nbsp;</span>pyplot的高级功能</a></span><ul class=\"toc-item\"><li><span><a href=\"#添加图例和注释\" data-toc-modified-id=\"添加图例和注释-4.2.1\"><span class=\"toc-item-num\">4.2.1&nbsp;&nbsp;</span>添加图例和注释</a></span></li><li><span><a href=\"#设置图形标题及坐标轴\" data-toc-modified-id=\"设置图形标题及坐标轴-4.2.2\"><span class=\"toc-item-num\">4.2.2&nbsp;&nbsp;</span>设置图形标题及坐标轴</a></span></li><li><span><a href=\"#添加网格线\" data-toc-modified-id=\"添加网格线-4.2.3\"><span class=\"toc-item-num\">4.2.3&nbsp;&nbsp;</span>添加网格线</a></span></li><li><span><a href=\"#绘制多个子图\" data-toc-modified-id=\"绘制多个子图-4.2.4\"><span class=\"toc-item-num\">4.2.4&nbsp;&nbsp;</span>绘制多个子图</a></span></li></ul></li><li><span><a href=\"#散点图\" data-toc-modified-id=\"散点图-4.3\"><span class=\"toc-item-num\">4.3&nbsp;&nbsp;</span>散点图</a></span></li><li><span><a href=\"#条形图和直方图\" data-toc-modified-id=\"条形图和直方图-4.4\"><span class=\"toc-item-num\">4.4&nbsp;&nbsp;</span>条形图和直方图</a></span><ul class=\"toc-item\"><li><span><a href=\"#并列条形图\" data-toc-modified-id=\"并列条形图-4.4.1\"><span class=\"toc-item-num\">4.4.1&nbsp;&nbsp;</span>并列条形图</a></span></li><li><span><a href=\"#叠加条形图\" data-toc-modified-id=\"叠加条形图-4.4.2\"><span class=\"toc-item-num\">4.4.2&nbsp;&nbsp;</span>叠加条形图</a></span></li><li><span><a href=\"#直方图\" data-toc-modified-id=\"直方图-4.4.3\"><span class=\"toc-item-num\">4.4.3&nbsp;&nbsp;</span>直方图</a></span></li></ul></li><li><span><a href=\"#饼图\" data-toc-modified-id=\"饼图-4.5\"><span class=\"toc-item-num\">4.5&nbsp;&nbsp;</span>饼图</a></span></li><li><span><a href=\"#箱形图\" data-toc-modified-id=\"箱形图-4.6\"><span class=\"toc-item-num\">4.6&nbsp;&nbsp;</span>箱形图</a></span></li><li><span><a href=\"#误差条\" data-toc-modified-id=\"误差条-4.7\"><span class=\"toc-item-num\">4.7&nbsp;&nbsp;</span>误差条</a></span></li><li><span><a href=\"#绘制三维图形\" data-toc-modified-id=\"绘制三维图形-4.8\"><span class=\"toc-item-num\">4.8&nbsp;&nbsp;</span>绘制三维图形</a></span></li><li><span><a href=\"#惊艳的Seaborn\" data-toc-modified-id=\"惊艳的Seaborn-4.9\"><span class=\"toc-item-num\">4.9&nbsp;&nbsp;</span>惊艳的Seaborn</a></span></li></ul></li><li><span><a href=\"#机器学习\" data-toc-modified-id=\"机器学习-5\"><span class=\"toc-item-num\">5&nbsp;&nbsp;</span>机器学习</a></span></li></ul></div>\n\n\n## 再入门基础\n由于之前的python课没能将一些基础的操作学得透彻，只能再回炉重造一下。\n\n### 包的引用\n```{python}\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport seaborn as sns\nimport statsmodels as sm\n```\n\n\n### 整数\nconda install nb_conda\n### 字符串\n\n\n### 行话\n由于你可能不太熟悉书中使用的一些有关编程和数据科学方面的常用术语，所以我在这里先给出其简单定义：\n\n数据规整（Munge/Munging/Wrangling） 指的是将非结构化和（或）散乱数据处理为结构化或整洁形式的整个过程。这几个词已经悄悄成为当今数据黑客们的行话了。Munge这个词跟Lunge押韵。\n\n伪码（Pseudocode） 算法或过程的“代码式”描述，而这些代码本身并不是实际有效的源代码。\n\n**语法糖（Syntactic sugar）** 这是一种编程语法，它并不会带来新的特性，但却能使代码更易读、更易写。\n\n通过输入代码并按下 ``return`` 运行任意Python语句。当只是输入一个变量，会显示代表的对象：\n   \n\nhttp://localhost:8888/\n手动打开notebook\n\n### 自省\n在变量前后使用问号，可以显示对象的信息：\n这可以作为对象的自省：\n若对象是一个函数或实例方法，定义过的文档都可显示出信息；\n\n### %run命令\n\n可以使用``%run``命令运行所有python程序。假设有一个文件：\n\n\n#%run ipython_script_test.py\n\n### jupyter notebook 中的神奇命令\n\n#### 编辑模式（按esc进入）\nEnter : 转入编辑模式\n\nShift-Enter : 运行本单元，选中下个单元\n\nCtrl-Enter : 运行本单元\n\nAlt-Enter : 运行本单元，在其下插入新单元\n\nY : 单元转入代码状态\n\nM :单元转入markdown状态\n\nR : 单元转入raw状态\n\n#### 命令模式（按enter进入）\nTab : 代码补全或缩进\n\nShift-Tab : 提示\n\nCtrl-] : 缩进\n\nCtrl-[ : 解除缩进\n\nCtrl-A : 全选\n\nCtrl-Z : 复原\n\nCtrl-Shift-Z : 再做\n\nCtrl-Y : 再做\n\nCtrl-Home : 跳到单元开头\n\nCtrl-Up : 跳到单元开头\n\nCtrl-End : 跳到单元末尾\n\nCtrl-Down : 跳到单元末尾\n\nCtrl-Left : 跳到左边一个字首\n\nCtrl-Right : 跳到右边一个字首\n\nCtrl-Backspace : 删除前面一个字\n\nCtrl-Delete : 删除后面一个字\n\n\n![image.png](attachment:image.png)\n\n\n笔记：赋值也被称作绑定，我们是把一个名字绑定给一个对象。变量名有时可能被称为绑定变量。\n\n\n## python数据结构\n\n### 元组\n最为简单的创建方式——通过逗号隔开即可\n\n\n用`turble`可以将任意序列转换为元组\n\n\n元组内创建的东西一旦创建就不可以改变了；因为元组的大小和内容不能修改，它的实例方法都很轻量。其中一个很有用的就是count（也适用于列表），它可以统计某个值得出现频率：\n\n### 列表\n\n与元组对比，列表的长度可变、内容可以被修改。你可以用方括号定义，或用`list`函数：\n\nappend可以用于添加元素,insert可以用于在特定位置插入元素（在指定位置的末尾）\n\n### 集合\n\n集合和字典差不多\n\n与字典类似，集合元素通常都是不可变的。要获得类似列表的元素，必须转换成元组：\n\n\n\n### NumPy\nNumPy最重要的一个特点就是其支持N维数组对象（即ndarray），该对象是一个快速而灵活的大数据集容器。你可以利用这种数组对整块数据执行一些数学运算，其语法跟标量元素之间的运算一样。numpy的数组与列表有点相似，但仍然不同的是要纯洁一点，只能是一个数组类型。\n\n因为data2是列表的列表，NumPy数组arr2的两个维度的shape是从data2引入的。可以用属性ndim和shape验证：\n\n\n\n每一个数组都有一个dtype属性，用于描述数组的数据类型。\nnp.array会自动推断数据类型。数据类型被存储在一个特殊的元数据dtype中。\n\n`arrage`方法根据start与stop指定的范围及step设定的步长来生成一个ndarray对象，start为起时值。\n```python\narange(start,stop,step,dtype)\n```\n\n`arange()`根据start与stop指定的范围设定的步长范围，生成一个ndarray对象。\n\n`print`的时候的样子是不同于直接输出的\n\n- 与`range()`函数较为相像，但`range()`生成的只能用于迭代。（属于一个迭代器）\n\n- `np.range()`的数据是左开右闭的，最后一个数取不到。当然可以在设置option中指定`endpoint=False`\n\n###  基本控制流\n\n### 复杂数据结构\n\n精度的不同，n.rate会进行转换，复杂性增大\n\n\n- 全是浮点数，全让他为整型；仍然是向下取整\n- numpy的储存方式，是object对象，元素都是一个list\n\n\n### 数组属性\n\n维度(dimension)都是由ndim属性来描述的。\n\n64bit 8byte\\\\\n100M byte 10M bit \n\n对于N维数组而言，还有一个重要的属性是shape（数组形状），形状主要用于表征数组每个维度的数量，一维数组的形状就是它的长度一维也称为1D张量(1D tensor)\n\n#### NumPy数组索引\n\n取出一列，当最终出来的结果和一行类似；\n其实这本身就是函数的概念；\n\n\n\n#### combination\n\n\n#### 随机森林\n\n?RandomForestRegressor\n\nA random forest is a meta estimator that fits a number of classifying\ndecision trees on various sub-samples of the dataset and uses averaging\nto improve the predictive accuracy and control over-fitting.\nThe sub-sample size is controlled with the `max_samples` parameter if\n`bootstrap=True` (default), otherwise the whole dataset is used to build\neach tree.\n\n# 数据改写\n\n#### 处理数据\n\n利用``numpy``函数生成数组\n\n需要由一个特定数字序列（0、1、序数和特定统计分布）组成的向量或矩阵，`Numpy`函数提供了很多的选择。\n\n从列表到数组\n\n生成随机整数的数组（数组无序且可能重复），可以使用下面命令：\n\n#### 从pandas中提取数据（后面补充）\n\n与`pandas`交互是可以很方便的，事实上，`pandas`是建立在Numpy上；\n\n### Numpy数组的运算\n\n而对于numpy，先需要将列表转化为数组，而这个就直接可以用加号(`+`)\n\n#### 算术运算\n\n还有很多的统计函数:\n- `sum()`\n- `min()`\n- `max()`\n- `mean()`\n- `std()`\n\n同时还有一些数学函数:\n- `sin()`\n- `cos()`\n\n\n#### 逐元素运算与张量点乘运算\n\nNumpy都是一个类矩阵的形式，因此NumPy中的数组在进行运算时候，都是基于基础算法库BLAS实现的。\n\n这时元素对元素原则，即数组的元素与元素位置对应相加。\n\n数学意义上的矩阵乘法并非如此，不同形状的矩阵可以进行乘法运算。只要满足第一个矩阵的列与第二个矩阵的行数相同。\n\n\n转化为矩阵\n\n`np.mat()` 将非矩阵的数据类型转换为矩阵输出\n\n#### 广播机制(broadcasting)\n\n#### 矩阵运算\n\n### 爱因斯坦求和约定\n\n`einsum()`不是一个简单的求和运算，而是一个高效的符号计算规则。\n\n一个例子：点乘公式\n$$\ns=\\sum_iv_iw_i\n$$\n但小爱认为这个太繁琐，因此重新发明了一个符号计算公式：\n$$\ns=v_iw^i\n$$\n\n仅仅用一个`einsum()`就可以实现求和、求外积、矩阵乘法等过程。\n`sum()`和`mat()`以及`trace()`就会显得非常繁琐\n\n`einsum()`理论上可支持任意多的参数。\n- 不同的输入变量之间的格式要用逗号隔开；\n- 输入格式字符和输出格式字符要用箭头分隔开；\n\n```python\nrescult = np.einsum('ijk,ijl->kl',a,b)\n```\n\n其中张量（数组）a就是一个三维矩阵，ijk是由三个字符构成，类似的输入张量b也是一个三维矩阵。\n\n`einsum()`通过求和，将一条线转化为一个点，也就是'i->‘的含义。\n\n### NumPy的轴方向\n\n元素的约简：实现在数量上的减少来反映数据，该原理同样适用于`mean`和`max`等\n\n### NumPy的高级索引\n\n索引要么是一个，要么是一片值，自然只能访问一个数组元素。\n\n花式索引是指将多个访问的元素索引汇集起来，构成一个整型数组，然后将这个内含索引的数组，整体作为一个目标数组的索引，一次能够读取多个重复的数组的元素。\n\n### 数组的堆叠操作\n\n将不同的数组需要堆叠stack操作，拼接为一个较大的数组，堆叠方式大致可以分为水平方向堆叠和垂直方向堆叠。\n\n### 数组NumPy的随机数\n\n# datascience process\n\n### EDA introduction\n\n探索性科学(exploratory Data Analysis,EDA)是数据科学的第一步。EDA是John Tukey在1977年提出。\n\n\n取出数据列表中的一些东西\n\n#### 异构列表\n\nuse the data to plot\n\n分相值需要不断修正得到，一般来说是所有观测值的平方根。len(iris)=150 sqrt(150)=14\n\n### 维数化简\n\n不得不将一些包含大量特征的数据集，其中有很多特征不必要的，有些特征包含丰富的信息，有些特征与预测相关。有些事完全不相关的。只是包含噪声或不相关信息。\n维数化简，消除输入数据集的某些特征。创建一个有限的特征数据集，这些特征包含所有需要的信息。从而更有效的预测目标变量。减少特征数意味着减少输出的变化性和复杂性（以及时间）。\n许多维数化简算法主要假设：数据包含加性高数白噪声（additive white gaussian Noise,AWGN),一种独立的高斯噪声。\n\n#### 协方差矩阵\n协方差矩阵给出了所有不同的特征对之间的相关性。\nIris中有四个特征，通过简单的图形显示容易计算。\n\n#### 主成分分析\n\n主成分分析(principal component analysis,PCA)帮助于定义更小的、更相关特征集合的技术。新的特征就是现有特征的线性组合/旋转（按道理不算新特征）\n第二个向量与第一个向量正交，包含剩余能量的大部分。\n理想的加性高斯白噪声下。\n\n\n#### 2.2.3处理大数据集\n\n要加载的数据集过大，而与采用的内存不适应，需要使用统一的机器学习方法。使用python可以加载数据到区块。该操作也称为数据流。\n数据集以连续流的形式流入数据框或其他的数据结构中。\n\n\n#### 3.3.3 一种用于大数据的PCA变型——Randomized PCA\n\nPCA的主要问题在于它所采用的奇异值分解的复杂性。Scikit-learn提供了一种基于随机SVD(randomiezd SVD)的算法。\n另一方面，随机SVD比经典SVD更为快速。\n\n目前来看的结果是与经典是接近的，但到大数据集中就显著会差异的。\n\n#### 3.3.4 潜在因素分析\n\nLFA是另一种实现数据集降维分析的技术。总体思路与PCA方法相近。不需要度输入信号进行正交分解，因此没有输出基。\napplied：主要在系统中有一个潜在因素或结构的情形。所有的特征是潜在因素经过线性变化后观测到的，具有任意波形发生器(AWG)的噪声。\n一般会认为，潜在因素符号高斯分布，具有归一化的协方差。\n\n#### 3.3.5 线性判别分析\n\nLDA是一种分类器，经常用于维数约简。LDA是一种监督的方法。需要标签集来优化维数化简的步骤。LDA产生输入特征的线性组合，试图建立最能区分不同类别的模型\n与PCA相比，LDA方法获得的输出数据集能够清晰地分出各个类别。\n\n\n### 3.4 异常检测和处理\n样本是数据科学核心。变量中出现异常高的值，不仅会改变变量的均值和方差等描述性的测量还会影响到很多从数据中学习到的算法。\n从而使得这些算法暴露给异常值。\n数据点成为异常值的原因：\n- 数据点表示极少发生的事件，但仍然是一个可能的数据；\n- 数据点表示经常发生的另一种分布。\n- 数据点明显是有某种类型的错误；\n\n#### 3.4.1 单变量异常检测\n数据点的异常如何去说明，单变量的问题通常用EDA分析和箱线图等可视化方式实现。\n极端值可以被当作异常值。若使用z-scores，得分绝对值高于3的观测值必需当作可疑异常值。\n观测量是用数据描述\n\n加载波士顿房价数据集，数据集中索引为3的变量CHAS是二进制（dummy variable）的，因此不使用该变量做。\n\n由此，单变量方法可以检测出很多的异常值，但不能检测出那些不是极端值的异常值。若他可以发现两个或两个以上的变量组合出现非正常值。仍然会发现这个异常值。\n所涉及的变量可能不是极端值，因此这个异常值就可能会漏选。\n\n\n#### 3.4.2 EllipticEnvelope\nEllipticEnvelope是用于找出数据总体分布的关键参数的函数。\n总体均值要考虑数据集中的所有变量。能够发现单变量和多变量的异常值。\n\n\n#### 3.4.3 oneclassSVM\nEllipticEnvelope适用于有控制参数的高斯分布假设，而OneClassSVM适用于一种通过学习来得知分布。\n- Kernel和Degree：这个两个变量是相关的。\n- Gamma：是一个与rbf核相关的参数。\n- nu ：是一个选择参数，决定模型是否必须符合一个精确的分布，还是应该尽量保持\n\n\n### 3.5 评分函数\n评估系统的性能并检查与目标距离，需要使用一个能对于结果进行评分的函数。通常有不同的评分函数分别处理二分类、多标号分类、回归或聚类问题。\n#### 3.5.1多标号分类\n对一个进行预测时候，需要多标号分类。\n\n- 混淆矩阵(confusion matrix):又称可能性表格错误矩阵，其每一列代表预测值，每一行代表的是实际的类别。一个完美的分类，其混淆矩阵所有非对角线元素的都应0。\n\n    \n\n准确率(accuracy):准确率表示的是预测标号也是实际标号的比例。\n\n#### 二值分类\n最常用的指标是ROC曲线或AUC曲线。ROC曲线是一种图形化方法，用于表示分类器性能是如何随可能的分类阀值改变的。\n\n\n#### 回归\nMAE（L1 norm）`mean_absolute_error`\n\nMSE（L2 norm）`mean_squared_error`\n\nR2，决定了预测器与目标变量之间的线性拟合的好坏，取值在0-1之间。取值越高表示模型越好。`sklearn.metrics.r2_score`\n\n\n### 交叉和验证\n加载数据之后，经过预处理、创建新的特征、检查异常值和其他不一致的数据点等过程，完成了机器学习的算法准备。\n机器学习通过观测一系列样本，使样本与它们的结果相匹配，从而抽取一系列能够成功泛化到新样本的规则。一种有监督的学习方法。\n首先加载一个数据集：\n\n这个方法使用数组x拟合一个模型，以正确预测出向量中十个类别。然后调用`.score()`的方法，指定同一个预测器，用向量真值y进行评价模型性能。\n这个得分表示的是样本内(in-sample)性能，也是学习算法的性能。\n\n###  交叉验证\n当样本不同时候，验证和测试的结果也会有所不同；\n所选择的假设往往是最好的，但并非总是如此；\n可行方案：交叉验证。SL:sklearn.cross_validation\n\n\n\n交叉验证，主要思想是在于将训练数据分为K组（折）训练模型k次，每次保留一个不同分组的不参与训练。\n十折是一个常见的设置。每次模型训练结束以后都会使用剩下的进行训练。\n标准差用于均值表示模型总体性能的公正估计。使用不同的模型交叉验证结果的均值。\n\n#### 3.7.1 使用交叉验证迭代器\n\n需要自己建立自己的交叉验证迭代器，`cross_validation`提供了一个较好的迭代器选择。\n##### KFold\n折数n变量已知，根据训练集的索引进行n次迭代，每次都在剩下都验证集上测试。\n\n\n#### 3.7.2 采样和自举方法\n\n采样方法和之前的方法不同，不分割训练集，对训练集进行二次抽样(resample)或(mbootstrap)\n- 需要去选择一部分可以使用的数据，就需要二次抽样\n- 二次抽样可以让你广泛的测试假设而又不用非常小的测试集中验证\n\n### 超参数优化\n机器学习不仅取决于学习算法，还会受到超参数和变量选择的影响。其中超参数是算法事先确定的，无法在训练过程中学习得到。\n变量选择能够帮助假设获得最佳的参数。\n\n## Pandas\n\n### Series数据\n\nSeries数据是Pandas的核心数据结构之一。\n\n\n#### Series创建\n\nSeries 的数据源用列表来填充，两者有相似之处，都是相同的类型，也可以是不同的类型。\nseries 增加对应的标签(label)作为索引，若没有，就默认是0～n-1内的索引值。\n\n因为这种对应关系，因此对于Series可以使用字典的方式来实现对应的dict的key,series中的value相对应。\n\nSeries中的数据是有序的，同时index和value是相互独立的，两者的索引也存在区别，Series和value是可变的。而字典的是不可变的。\n\n一些指标的含义：\n- `count` 一列数据的个数\n- `mean` 一列数据的均值\n- `25%`:一列数据中前25的分位数\n\n#### 数据访问\n\n可以通过特定索引值来访问、修改索引位置对应的数值，series对象再本质上就是一个带有Numpy数组，因此Numpy可直接运用于Series中。\n\n堆叠操作:`append()`\n\n#### Series中的向量化操作与布尔索引\n\n任何NaN(Not a Number)参与的计算，返回的结果依然是NaN。\n\n向量化加法：\n\n\n会产生一个与原矩阵维度类似的bool矩阵。这个布尔矩阵也可以作为Series对象对应下标，用于获得值为True的位置的对应的数值。从而达到抽取特定样本的目的。\n\n#### 切片操作\n\n通过索引切片或处理Series中的一个或多个值，返回的结果依然是Series对象。\n\n提取的是第一和第二个元素，第三个元素访问不到。\n\n`isnull()`还可以把Series对象作为参数\n\n数据量庞大时候，缺失值可能处于正常数据中，这时候可以用布尔表达式形式，将这些数据筛选出来。\n\n#### 删除和添加\n\n利用Pandas中的`drop()`\n\n添加元素\n\n### DataFrame\n\n若将Series看作Excel的一列，则DataFrame就是一张表\n\n改变index行名，显示指定列名\n\n#### 访问DataFrame中的列和行\n\n在pandas，Dataframe可以将列的名称作为DataFrame对象的属性来访问数据。\n\n上述两者是等价的\n\n#### DataFrame中的删除操作\n\n类似于Series，可以同样使用`drop`来删除一行或一列\n\n#### Dataframe的轴方向\n\n### 基于Pandas的文件读取与分析\n\n## Matplotlib 与Seaborn可视化分析\n\n### Matplotlib与图形绘制\n\n上述做法可以用numpy来得到简化\n\n`linspace(linspace(start,stop,num=50))`能够批量生产指定区间内的数量为num的均匀间隔的数组向量。\n\n### pyplot的高级功能\n\n#### 添加图例和注释\n\n#### 设置图形标题及坐标轴\n\n#### 添加网格线\n\n#### 绘制多个子图\n\n实际上有时候需要多个子图，使用`subplot()`\n\n### 散点图\n\n其中参数`alpha`表示透明度，s就是`plot()`中的markersize参数。\n\n### 条形图和直方图\n\n#### 并列条形图\n\n#### 叠加条形图\n\n#### 直方图\n\n### 饼图\n\n### 箱形图\n\n### 误差条\n\n### 绘制三维图形\n\n### 惊艳的Seaborn\n\nSeaborn基于Matplotlib的数据可视化库，在Matplotlib的基础上实现了一些好用的功能，在代码形式上会更加像R语言上的ggplot。\n\n## 机器学习\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../styles.css"],"output-file":"python学习笔记0922.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.124","theme":"cosmo","title-block-banner":true},"extensions":{"book":{"multiFile":true}}}}}